# coding: utf-8

"""
    API documentation

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 0.0.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictInt, StrictStr, field_validator
from typing import Optional
from typing_extensions import Annotated
from openapi_client.models.search_term_type_collections_get200_response import SearchTermTypeCollectionsGet200Response
from openapi_client.models.search_term_type_makes_get200_response import SearchTermTypeMakesGet200Response
from openapi_client.models.search_term_type_things_get200_response import SearchTermTypeThingsGet200Response
from openapi_client.models.search_term_type_users_get200_response import SearchTermTypeUsersGet200Response

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class SearchApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def search_tag_tag_get(
        self,
        tag: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """search_tag_tag_get


        :param tag:
        :type tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_tag_tag_get_serialize(
            tag=tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': "ThingsPost401Response",
            '403': "ThingsPost403Response",
            '404': "ThingsPost404Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_tag_tag_get_with_http_info(
        self,
        tag: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """search_tag_tag_get


        :param tag:
        :type tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_tag_tag_get_serialize(
            tag=tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': "ThingsPost401Response",
            '403': "ThingsPost403Response",
            '404': "ThingsPost404Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_tag_tag_get_without_preload_content(
        self,
        tag: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """search_tag_tag_get


        :param tag:
        :type tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_tag_tag_get_serialize(
            tag=tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': "ThingsPost401Response",
            '403': "ThingsPost403Response",
            '404': "ThingsPost404Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_tag_tag_get_serialize(
        self,
        tag,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tag is not None:
            _path_params['tag'] = tag
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/search/{tag}/tag',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_term_autocomplete_get(
        self,
        term: Annotated[Optional[StrictStr], Field(description="The search query to perform")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """search_term_autocomplete_get

        Search data by term for autocomplete

        :param term: The search query to perform
        :type term: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_term_autocomplete_get_serialize(
            term=term,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': "ThingsPost401Response",
            '403': "ThingsPost403Response",
            '404': "ThingsPost404Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_term_autocomplete_get_with_http_info(
        self,
        term: Annotated[Optional[StrictStr], Field(description="The search query to perform")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """search_term_autocomplete_get

        Search data by term for autocomplete

        :param term: The search query to perform
        :type term: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_term_autocomplete_get_serialize(
            term=term,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': "ThingsPost401Response",
            '403': "ThingsPost403Response",
            '404': "ThingsPost404Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_term_autocomplete_get_without_preload_content(
        self,
        term: Annotated[Optional[StrictStr], Field(description="The search query to perform")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """search_term_autocomplete_get

        Search data by term for autocomplete

        :param term: The search query to perform
        :type term: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_term_autocomplete_get_serialize(
            term=term,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': "ThingsPost401Response",
            '403': "ThingsPost403Response",
            '404': "ThingsPost404Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_term_autocomplete_get_serialize(
        self,
        term,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if term is not None:
            _path_params['term'] = term
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/search/{term}/autocomplete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_term_typecollections_get(
        self,
        term: Annotated[Optional[StrictStr], Field(description="The search query to perform")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page for pagination")] = None,
        per_page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Amount of results to show per page")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort method")] = None,
        is_featured: Annotated[Optional[StrictInt], Field(description="Only show Collections that have been featured")] = None,
        liked_by: Annotated[Optional[StrictInt], Field(description="Only show Collections liked by this user ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SearchTermTypeCollectionsGet200Response:
        """Search for Collections

        See [page](https://www.notion.so/makerbot/Thingiverse-Search-API-f7ce7608d54d44f7a2b902a83194a8b2) for complete documentation and all possible parameters.

        :param term: The search query to perform
        :type term: str
        :param page: Page for pagination
        :type page: int
        :param per_page: Amount of results to show per page
        :type per_page: int
        :param sort: Sort method
        :type sort: str
        :param is_featured: Only show Collections that have been featured
        :type is_featured: int
        :param liked_by: Only show Collections liked by this user ID
        :type liked_by: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_term_typecollections_get_serialize(
            term=term,
            page=page,
            per_page=per_page,
            sort=sort,
            is_featured=is_featured,
            liked_by=liked_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SearchTermTypeCollectionsGet200Response",
            '401': "ThingsPost401Response",
            '403': "ThingsPost403Response",
            '404': "ThingsPost404Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_term_typecollections_get_with_http_info(
        self,
        term: Annotated[Optional[StrictStr], Field(description="The search query to perform")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page for pagination")] = None,
        per_page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Amount of results to show per page")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort method")] = None,
        is_featured: Annotated[Optional[StrictInt], Field(description="Only show Collections that have been featured")] = None,
        liked_by: Annotated[Optional[StrictInt], Field(description="Only show Collections liked by this user ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SearchTermTypeCollectionsGet200Response]:
        """Search for Collections

        See [page](https://www.notion.so/makerbot/Thingiverse-Search-API-f7ce7608d54d44f7a2b902a83194a8b2) for complete documentation and all possible parameters.

        :param term: The search query to perform
        :type term: str
        :param page: Page for pagination
        :type page: int
        :param per_page: Amount of results to show per page
        :type per_page: int
        :param sort: Sort method
        :type sort: str
        :param is_featured: Only show Collections that have been featured
        :type is_featured: int
        :param liked_by: Only show Collections liked by this user ID
        :type liked_by: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_term_typecollections_get_serialize(
            term=term,
            page=page,
            per_page=per_page,
            sort=sort,
            is_featured=is_featured,
            liked_by=liked_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SearchTermTypeCollectionsGet200Response",
            '401': "ThingsPost401Response",
            '403': "ThingsPost403Response",
            '404': "ThingsPost404Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_term_typecollections_get_without_preload_content(
        self,
        term: Annotated[Optional[StrictStr], Field(description="The search query to perform")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page for pagination")] = None,
        per_page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Amount of results to show per page")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort method")] = None,
        is_featured: Annotated[Optional[StrictInt], Field(description="Only show Collections that have been featured")] = None,
        liked_by: Annotated[Optional[StrictInt], Field(description="Only show Collections liked by this user ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search for Collections

        See [page](https://www.notion.so/makerbot/Thingiverse-Search-API-f7ce7608d54d44f7a2b902a83194a8b2) for complete documentation and all possible parameters.

        :param term: The search query to perform
        :type term: str
        :param page: Page for pagination
        :type page: int
        :param per_page: Amount of results to show per page
        :type per_page: int
        :param sort: Sort method
        :type sort: str
        :param is_featured: Only show Collections that have been featured
        :type is_featured: int
        :param liked_by: Only show Collections liked by this user ID
        :type liked_by: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_term_typecollections_get_serialize(
            term=term,
            page=page,
            per_page=per_page,
            sort=sort,
            is_featured=is_featured,
            liked_by=liked_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SearchTermTypeCollectionsGet200Response",
            '401': "ThingsPost401Response",
            '403': "ThingsPost403Response",
            '404': "ThingsPost404Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_term_typecollections_get_serialize(
        self,
        term,
        page,
        per_page,
        sort,
        is_featured,
        liked_by,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if term is not None:
            _path_params['term'] = term
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if per_page is not None:
            
            _query_params.append(('per_page', per_page))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if is_featured is not None:
            
            _query_params.append(('is_featured', is_featured))
            
        if liked_by is not None:
            
            _query_params.append(('liked_by', liked_by))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/search/{term}/?type=collections',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_term_typemakes_get(
        self,
        term: Annotated[Optional[StrictStr], Field(description="The search query to perform")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page for pagination")] = None,
        per_page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Amount of results to show per page")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort method")] = None,
        user_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Only show Makes made by this user ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SearchTermTypeMakesGet200Response:
        """Search for Makes

        See [page](https://www.notion.so/makerbot/Thingiverse-Search-API-f7ce7608d54d44f7a2b902a83194a8b2) for complete documentation and all possible parameters.

        :param term: The search query to perform
        :type term: str
        :param page: Page for pagination
        :type page: int
        :param per_page: Amount of results to show per page
        :type per_page: int
        :param sort: Sort method
        :type sort: str
        :param user_id: Only show Makes made by this user ID
        :type user_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_term_typemakes_get_serialize(
            term=term,
            page=page,
            per_page=per_page,
            sort=sort,
            user_id=user_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SearchTermTypeMakesGet200Response",
            '401': "ThingsPost401Response",
            '403': "ThingsPost403Response",
            '404': "ThingsPost404Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_term_typemakes_get_with_http_info(
        self,
        term: Annotated[Optional[StrictStr], Field(description="The search query to perform")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page for pagination")] = None,
        per_page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Amount of results to show per page")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort method")] = None,
        user_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Only show Makes made by this user ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SearchTermTypeMakesGet200Response]:
        """Search for Makes

        See [page](https://www.notion.so/makerbot/Thingiverse-Search-API-f7ce7608d54d44f7a2b902a83194a8b2) for complete documentation and all possible parameters.

        :param term: The search query to perform
        :type term: str
        :param page: Page for pagination
        :type page: int
        :param per_page: Amount of results to show per page
        :type per_page: int
        :param sort: Sort method
        :type sort: str
        :param user_id: Only show Makes made by this user ID
        :type user_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_term_typemakes_get_serialize(
            term=term,
            page=page,
            per_page=per_page,
            sort=sort,
            user_id=user_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SearchTermTypeMakesGet200Response",
            '401': "ThingsPost401Response",
            '403': "ThingsPost403Response",
            '404': "ThingsPost404Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_term_typemakes_get_without_preload_content(
        self,
        term: Annotated[Optional[StrictStr], Field(description="The search query to perform")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page for pagination")] = None,
        per_page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Amount of results to show per page")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort method")] = None,
        user_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Only show Makes made by this user ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search for Makes

        See [page](https://www.notion.so/makerbot/Thingiverse-Search-API-f7ce7608d54d44f7a2b902a83194a8b2) for complete documentation and all possible parameters.

        :param term: The search query to perform
        :type term: str
        :param page: Page for pagination
        :type page: int
        :param per_page: Amount of results to show per page
        :type per_page: int
        :param sort: Sort method
        :type sort: str
        :param user_id: Only show Makes made by this user ID
        :type user_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_term_typemakes_get_serialize(
            term=term,
            page=page,
            per_page=per_page,
            sort=sort,
            user_id=user_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SearchTermTypeMakesGet200Response",
            '401': "ThingsPost401Response",
            '403': "ThingsPost403Response",
            '404': "ThingsPost404Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_term_typemakes_get_serialize(
        self,
        term,
        page,
        per_page,
        sort,
        user_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if term is not None:
            _path_params['term'] = term
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if per_page is not None:
            
            _query_params.append(('per_page', per_page))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if user_id is not None:
            
            _query_params.append(('user_id', user_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/search/{term}/?type=makes',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_term_typethings_get(
        self,
        term: Annotated[Optional[StrictStr], Field(description="The search query to perform")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page for pagination")] = None,
        per_page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Amount of results to show per page")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort method")] = None,
        posted_before: Annotated[Optional[StrictStr], Field(description="Only show Things posted before this date. Check out the Elasticsearch date math [docs](https://www.elastic.co/guide/en/elasticsearch/reference/current/common-options.html#date-math)")] = None,
        posted_after: Annotated[Optional[StrictStr], Field(description="Only show Things posted after this date. Check out the Elasticsearch date math [docs](https://www.elastic.co/guide/en/elasticsearch/reference/current/common-options.html#date-math)")] = None,
        is_edu_approved: Annotated[Optional[StrictStr], Field(description="EDU - Only show educational Things")] = None,
        subjects: Annotated[Optional[StrictStr], Field(description="EDU - Only show Things marked as for these subject IDs")] = None,
        grades: Annotated[Optional[StrictStr], Field(description="EDU - Only show Things marked as for these grade IDs")] = None,
        standards: Annotated[Optional[StrictStr], Field(description="EDU - Only show Things marked as for these standard IDs")] = None,
        license: Annotated[Optional[StrictStr], Field(description="Only show Things with this license (e.g. \"ccsa\" for Creative Commons - Attribution - Share Alike)")] = None,
        customizable: Annotated[Optional[StrictStr], Field(description="Only show customizable Things")] = None,
        show_customized: Annotated[Optional[StrictStr], Field(description="Also include Things that have been customized from a different Thing. By default these are filtered out")] = None,
        order_print: Annotated[Optional[StrictStr], Field(description="Only show Things that have the \"Order A Print\" feature enabled")] = None,
        has_makes: Annotated[Optional[StrictInt], Field(description="Only show Things that have Makes")] = None,
        is_featured: Annotated[Optional[StrictInt], Field(description="Only show Things that have Makes")] = None,
        is_fis_challenge_winnereatured: Annotated[Optional[StrictInt], Field(description="Only show Things that are marked as a challenge winner")] = None,
        liked_by: Annotated[Optional[StrictStr], Field(description="Only show Things liked by this user ID")] = None,
        collected_by: Annotated[Optional[StrictStr], Field(description="Only show Things collected by this user ID")] = None,
        made_by: Annotated[Optional[StrictStr], Field(description="Only show Things made by this user ID")] = None,
        is_derivative: Annotated[Optional[StrictInt], Field(description="Only show remixes")] = None,
        category_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Only show Things in this category ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SearchTermTypeThingsGet200Response:
        """Search for Things

        See [page](https://www.notion.so/makerbot/Thingiverse-Search-API-f7ce7608d54d44f7a2b902a83194a8b2) for complete documentation and all possible parameters.

        :param term: The search query to perform
        :type term: str
        :param page: Page for pagination
        :type page: int
        :param per_page: Amount of results to show per page
        :type per_page: int
        :param sort: Sort method
        :type sort: str
        :param posted_before: Only show Things posted before this date. Check out the Elasticsearch date math [docs](https://www.elastic.co/guide/en/elasticsearch/reference/current/common-options.html#date-math)
        :type posted_before: str
        :param posted_after: Only show Things posted after this date. Check out the Elasticsearch date math [docs](https://www.elastic.co/guide/en/elasticsearch/reference/current/common-options.html#date-math)
        :type posted_after: str
        :param is_edu_approved: EDU - Only show educational Things
        :type is_edu_approved: str
        :param subjects: EDU - Only show Things marked as for these subject IDs
        :type subjects: str
        :param grades: EDU - Only show Things marked as for these grade IDs
        :type grades: str
        :param standards: EDU - Only show Things marked as for these standard IDs
        :type standards: str
        :param license: Only show Things with this license (e.g. \"ccsa\" for Creative Commons - Attribution - Share Alike)
        :type license: str
        :param customizable: Only show customizable Things
        :type customizable: str
        :param show_customized: Also include Things that have been customized from a different Thing. By default these are filtered out
        :type show_customized: str
        :param order_print: Only show Things that have the \"Order A Print\" feature enabled
        :type order_print: str
        :param has_makes: Only show Things that have Makes
        :type has_makes: int
        :param is_featured: Only show Things that have Makes
        :type is_featured: int
        :param is_fis_challenge_winnereatured: Only show Things that are marked as a challenge winner
        :type is_fis_challenge_winnereatured: int
        :param liked_by: Only show Things liked by this user ID
        :type liked_by: str
        :param collected_by: Only show Things collected by this user ID
        :type collected_by: str
        :param made_by: Only show Things made by this user ID
        :type made_by: str
        :param is_derivative: Only show remixes
        :type is_derivative: int
        :param category_id: Only show Things in this category ID
        :type category_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_term_typethings_get_serialize(
            term=term,
            page=page,
            per_page=per_page,
            sort=sort,
            posted_before=posted_before,
            posted_after=posted_after,
            is_edu_approved=is_edu_approved,
            subjects=subjects,
            grades=grades,
            standards=standards,
            license=license,
            customizable=customizable,
            show_customized=show_customized,
            order_print=order_print,
            has_makes=has_makes,
            is_featured=is_featured,
            is_fis_challenge_winnereatured=is_fis_challenge_winnereatured,
            liked_by=liked_by,
            collected_by=collected_by,
            made_by=made_by,
            is_derivative=is_derivative,
            category_id=category_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SearchTermTypeThingsGet200Response",
            '401': "ThingsPost401Response",
            '403': "ThingsPost403Response",
            '404': "ThingsPost404Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_term_typethings_get_with_http_info(
        self,
        term: Annotated[Optional[StrictStr], Field(description="The search query to perform")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page for pagination")] = None,
        per_page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Amount of results to show per page")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort method")] = None,
        posted_before: Annotated[Optional[StrictStr], Field(description="Only show Things posted before this date. Check out the Elasticsearch date math [docs](https://www.elastic.co/guide/en/elasticsearch/reference/current/common-options.html#date-math)")] = None,
        posted_after: Annotated[Optional[StrictStr], Field(description="Only show Things posted after this date. Check out the Elasticsearch date math [docs](https://www.elastic.co/guide/en/elasticsearch/reference/current/common-options.html#date-math)")] = None,
        is_edu_approved: Annotated[Optional[StrictStr], Field(description="EDU - Only show educational Things")] = None,
        subjects: Annotated[Optional[StrictStr], Field(description="EDU - Only show Things marked as for these subject IDs")] = None,
        grades: Annotated[Optional[StrictStr], Field(description="EDU - Only show Things marked as for these grade IDs")] = None,
        standards: Annotated[Optional[StrictStr], Field(description="EDU - Only show Things marked as for these standard IDs")] = None,
        license: Annotated[Optional[StrictStr], Field(description="Only show Things with this license (e.g. \"ccsa\" for Creative Commons - Attribution - Share Alike)")] = None,
        customizable: Annotated[Optional[StrictStr], Field(description="Only show customizable Things")] = None,
        show_customized: Annotated[Optional[StrictStr], Field(description="Also include Things that have been customized from a different Thing. By default these are filtered out")] = None,
        order_print: Annotated[Optional[StrictStr], Field(description="Only show Things that have the \"Order A Print\" feature enabled")] = None,
        has_makes: Annotated[Optional[StrictInt], Field(description="Only show Things that have Makes")] = None,
        is_featured: Annotated[Optional[StrictInt], Field(description="Only show Things that have Makes")] = None,
        is_fis_challenge_winnereatured: Annotated[Optional[StrictInt], Field(description="Only show Things that are marked as a challenge winner")] = None,
        liked_by: Annotated[Optional[StrictStr], Field(description="Only show Things liked by this user ID")] = None,
        collected_by: Annotated[Optional[StrictStr], Field(description="Only show Things collected by this user ID")] = None,
        made_by: Annotated[Optional[StrictStr], Field(description="Only show Things made by this user ID")] = None,
        is_derivative: Annotated[Optional[StrictInt], Field(description="Only show remixes")] = None,
        category_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Only show Things in this category ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SearchTermTypeThingsGet200Response]:
        """Search for Things

        See [page](https://www.notion.so/makerbot/Thingiverse-Search-API-f7ce7608d54d44f7a2b902a83194a8b2) for complete documentation and all possible parameters.

        :param term: The search query to perform
        :type term: str
        :param page: Page for pagination
        :type page: int
        :param per_page: Amount of results to show per page
        :type per_page: int
        :param sort: Sort method
        :type sort: str
        :param posted_before: Only show Things posted before this date. Check out the Elasticsearch date math [docs](https://www.elastic.co/guide/en/elasticsearch/reference/current/common-options.html#date-math)
        :type posted_before: str
        :param posted_after: Only show Things posted after this date. Check out the Elasticsearch date math [docs](https://www.elastic.co/guide/en/elasticsearch/reference/current/common-options.html#date-math)
        :type posted_after: str
        :param is_edu_approved: EDU - Only show educational Things
        :type is_edu_approved: str
        :param subjects: EDU - Only show Things marked as for these subject IDs
        :type subjects: str
        :param grades: EDU - Only show Things marked as for these grade IDs
        :type grades: str
        :param standards: EDU - Only show Things marked as for these standard IDs
        :type standards: str
        :param license: Only show Things with this license (e.g. \"ccsa\" for Creative Commons - Attribution - Share Alike)
        :type license: str
        :param customizable: Only show customizable Things
        :type customizable: str
        :param show_customized: Also include Things that have been customized from a different Thing. By default these are filtered out
        :type show_customized: str
        :param order_print: Only show Things that have the \"Order A Print\" feature enabled
        :type order_print: str
        :param has_makes: Only show Things that have Makes
        :type has_makes: int
        :param is_featured: Only show Things that have Makes
        :type is_featured: int
        :param is_fis_challenge_winnereatured: Only show Things that are marked as a challenge winner
        :type is_fis_challenge_winnereatured: int
        :param liked_by: Only show Things liked by this user ID
        :type liked_by: str
        :param collected_by: Only show Things collected by this user ID
        :type collected_by: str
        :param made_by: Only show Things made by this user ID
        :type made_by: str
        :param is_derivative: Only show remixes
        :type is_derivative: int
        :param category_id: Only show Things in this category ID
        :type category_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_term_typethings_get_serialize(
            term=term,
            page=page,
            per_page=per_page,
            sort=sort,
            posted_before=posted_before,
            posted_after=posted_after,
            is_edu_approved=is_edu_approved,
            subjects=subjects,
            grades=grades,
            standards=standards,
            license=license,
            customizable=customizable,
            show_customized=show_customized,
            order_print=order_print,
            has_makes=has_makes,
            is_featured=is_featured,
            is_fis_challenge_winnereatured=is_fis_challenge_winnereatured,
            liked_by=liked_by,
            collected_by=collected_by,
            made_by=made_by,
            is_derivative=is_derivative,
            category_id=category_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SearchTermTypeThingsGet200Response",
            '401': "ThingsPost401Response",
            '403': "ThingsPost403Response",
            '404': "ThingsPost404Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_term_typethings_get_without_preload_content(
        self,
        term: Annotated[Optional[StrictStr], Field(description="The search query to perform")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page for pagination")] = None,
        per_page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Amount of results to show per page")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort method")] = None,
        posted_before: Annotated[Optional[StrictStr], Field(description="Only show Things posted before this date. Check out the Elasticsearch date math [docs](https://www.elastic.co/guide/en/elasticsearch/reference/current/common-options.html#date-math)")] = None,
        posted_after: Annotated[Optional[StrictStr], Field(description="Only show Things posted after this date. Check out the Elasticsearch date math [docs](https://www.elastic.co/guide/en/elasticsearch/reference/current/common-options.html#date-math)")] = None,
        is_edu_approved: Annotated[Optional[StrictStr], Field(description="EDU - Only show educational Things")] = None,
        subjects: Annotated[Optional[StrictStr], Field(description="EDU - Only show Things marked as for these subject IDs")] = None,
        grades: Annotated[Optional[StrictStr], Field(description="EDU - Only show Things marked as for these grade IDs")] = None,
        standards: Annotated[Optional[StrictStr], Field(description="EDU - Only show Things marked as for these standard IDs")] = None,
        license: Annotated[Optional[StrictStr], Field(description="Only show Things with this license (e.g. \"ccsa\" for Creative Commons - Attribution - Share Alike)")] = None,
        customizable: Annotated[Optional[StrictStr], Field(description="Only show customizable Things")] = None,
        show_customized: Annotated[Optional[StrictStr], Field(description="Also include Things that have been customized from a different Thing. By default these are filtered out")] = None,
        order_print: Annotated[Optional[StrictStr], Field(description="Only show Things that have the \"Order A Print\" feature enabled")] = None,
        has_makes: Annotated[Optional[StrictInt], Field(description="Only show Things that have Makes")] = None,
        is_featured: Annotated[Optional[StrictInt], Field(description="Only show Things that have Makes")] = None,
        is_fis_challenge_winnereatured: Annotated[Optional[StrictInt], Field(description="Only show Things that are marked as a challenge winner")] = None,
        liked_by: Annotated[Optional[StrictStr], Field(description="Only show Things liked by this user ID")] = None,
        collected_by: Annotated[Optional[StrictStr], Field(description="Only show Things collected by this user ID")] = None,
        made_by: Annotated[Optional[StrictStr], Field(description="Only show Things made by this user ID")] = None,
        is_derivative: Annotated[Optional[StrictInt], Field(description="Only show remixes")] = None,
        category_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Only show Things in this category ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search for Things

        See [page](https://www.notion.so/makerbot/Thingiverse-Search-API-f7ce7608d54d44f7a2b902a83194a8b2) for complete documentation and all possible parameters.

        :param term: The search query to perform
        :type term: str
        :param page: Page for pagination
        :type page: int
        :param per_page: Amount of results to show per page
        :type per_page: int
        :param sort: Sort method
        :type sort: str
        :param posted_before: Only show Things posted before this date. Check out the Elasticsearch date math [docs](https://www.elastic.co/guide/en/elasticsearch/reference/current/common-options.html#date-math)
        :type posted_before: str
        :param posted_after: Only show Things posted after this date. Check out the Elasticsearch date math [docs](https://www.elastic.co/guide/en/elasticsearch/reference/current/common-options.html#date-math)
        :type posted_after: str
        :param is_edu_approved: EDU - Only show educational Things
        :type is_edu_approved: str
        :param subjects: EDU - Only show Things marked as for these subject IDs
        :type subjects: str
        :param grades: EDU - Only show Things marked as for these grade IDs
        :type grades: str
        :param standards: EDU - Only show Things marked as for these standard IDs
        :type standards: str
        :param license: Only show Things with this license (e.g. \"ccsa\" for Creative Commons - Attribution - Share Alike)
        :type license: str
        :param customizable: Only show customizable Things
        :type customizable: str
        :param show_customized: Also include Things that have been customized from a different Thing. By default these are filtered out
        :type show_customized: str
        :param order_print: Only show Things that have the \"Order A Print\" feature enabled
        :type order_print: str
        :param has_makes: Only show Things that have Makes
        :type has_makes: int
        :param is_featured: Only show Things that have Makes
        :type is_featured: int
        :param is_fis_challenge_winnereatured: Only show Things that are marked as a challenge winner
        :type is_fis_challenge_winnereatured: int
        :param liked_by: Only show Things liked by this user ID
        :type liked_by: str
        :param collected_by: Only show Things collected by this user ID
        :type collected_by: str
        :param made_by: Only show Things made by this user ID
        :type made_by: str
        :param is_derivative: Only show remixes
        :type is_derivative: int
        :param category_id: Only show Things in this category ID
        :type category_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_term_typethings_get_serialize(
            term=term,
            page=page,
            per_page=per_page,
            sort=sort,
            posted_before=posted_before,
            posted_after=posted_after,
            is_edu_approved=is_edu_approved,
            subjects=subjects,
            grades=grades,
            standards=standards,
            license=license,
            customizable=customizable,
            show_customized=show_customized,
            order_print=order_print,
            has_makes=has_makes,
            is_featured=is_featured,
            is_fis_challenge_winnereatured=is_fis_challenge_winnereatured,
            liked_by=liked_by,
            collected_by=collected_by,
            made_by=made_by,
            is_derivative=is_derivative,
            category_id=category_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SearchTermTypeThingsGet200Response",
            '401': "ThingsPost401Response",
            '403': "ThingsPost403Response",
            '404': "ThingsPost404Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_term_typethings_get_serialize(
        self,
        term,
        page,
        per_page,
        sort,
        posted_before,
        posted_after,
        is_edu_approved,
        subjects,
        grades,
        standards,
        license,
        customizable,
        show_customized,
        order_print,
        has_makes,
        is_featured,
        is_fis_challenge_winnereatured,
        liked_by,
        collected_by,
        made_by,
        is_derivative,
        category_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if term is not None:
            _path_params['term'] = term
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if per_page is not None:
            
            _query_params.append(('per_page', per_page))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if posted_before is not None:
            
            _query_params.append(('posted_before', posted_before))
            
        if posted_after is not None:
            
            _query_params.append(('posted_after', posted_after))
            
        if is_edu_approved is not None:
            
            _query_params.append(('is_edu_approved', is_edu_approved))
            
        if subjects is not None:
            
            _query_params.append(('subjects', subjects))
            
        if grades is not None:
            
            _query_params.append(('grades', grades))
            
        if standards is not None:
            
            _query_params.append(('standards', standards))
            
        if license is not None:
            
            _query_params.append(('license', license))
            
        if customizable is not None:
            
            _query_params.append(('customizable', customizable))
            
        if show_customized is not None:
            
            _query_params.append(('show_customized', show_customized))
            
        if order_print is not None:
            
            _query_params.append(('order_print', order_print))
            
        if has_makes is not None:
            
            _query_params.append(('has_makes', has_makes))
            
        if is_featured is not None:
            
            _query_params.append(('is_featured', is_featured))
            
        if is_fis_challenge_winnereatured is not None:
            
            _query_params.append(('is_fis_challenge_winnereatured', is_fis_challenge_winnereatured))
            
        if liked_by is not None:
            
            _query_params.append(('liked_by', liked_by))
            
        if collected_by is not None:
            
            _query_params.append(('collected_by', collected_by))
            
        if made_by is not None:
            
            _query_params.append(('made_by', made_by))
            
        if is_derivative is not None:
            
            _query_params.append(('is_derivative', is_derivative))
            
        if category_id is not None:
            
            _query_params.append(('category_id', category_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/search/{term}/?type=things',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_term_typeusers_get(
        self,
        term: Annotated[Optional[StrictStr], Field(description="The search query to perform")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page for pagination")] = None,
        per_page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Amount of results to show per page")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort method")] = None,
        users_thing_count: Annotated[Optional[StrictInt], Field(description="Only show users that have at least 1 published Thing")] = None,
        users_user_types: Annotated[Optional[StrictInt], Field(description="Only show users that are of this type")] = None,
        skill_level: Annotated[Optional[StrictStr], Field(description="Only show users that are of this skill level")] = None,
        programs: Annotated[Optional[StrictInt], Field(description="Only show users that use this design program")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SearchTermTypeUsersGet200Response:
        """Search for Users

        See [page](https://www.notion.so/makerbot/Thingiverse-Search-API-f7ce7608d54d44f7a2b902a83194a8b2) for complete documentation and all possible parameters.

        :param term: The search query to perform
        :type term: str
        :param page: Page for pagination
        :type page: int
        :param per_page: Amount of results to show per page
        :type per_page: int
        :param sort: Sort method
        :type sort: str
        :param users_thing_count: Only show users that have at least 1 published Thing
        :type users_thing_count: int
        :param users_user_types: Only show users that are of this type
        :type users_user_types: int
        :param skill_level: Only show users that are of this skill level
        :type skill_level: str
        :param programs: Only show users that use this design program
        :type programs: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_term_typeusers_get_serialize(
            term=term,
            page=page,
            per_page=per_page,
            sort=sort,
            users_thing_count=users_thing_count,
            users_user_types=users_user_types,
            skill_level=skill_level,
            programs=programs,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SearchTermTypeUsersGet200Response",
            '401': "ThingsPost401Response",
            '403': "ThingsPost403Response",
            '404': "ThingsPost404Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_term_typeusers_get_with_http_info(
        self,
        term: Annotated[Optional[StrictStr], Field(description="The search query to perform")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page for pagination")] = None,
        per_page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Amount of results to show per page")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort method")] = None,
        users_thing_count: Annotated[Optional[StrictInt], Field(description="Only show users that have at least 1 published Thing")] = None,
        users_user_types: Annotated[Optional[StrictInt], Field(description="Only show users that are of this type")] = None,
        skill_level: Annotated[Optional[StrictStr], Field(description="Only show users that are of this skill level")] = None,
        programs: Annotated[Optional[StrictInt], Field(description="Only show users that use this design program")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SearchTermTypeUsersGet200Response]:
        """Search for Users

        See [page](https://www.notion.so/makerbot/Thingiverse-Search-API-f7ce7608d54d44f7a2b902a83194a8b2) for complete documentation and all possible parameters.

        :param term: The search query to perform
        :type term: str
        :param page: Page for pagination
        :type page: int
        :param per_page: Amount of results to show per page
        :type per_page: int
        :param sort: Sort method
        :type sort: str
        :param users_thing_count: Only show users that have at least 1 published Thing
        :type users_thing_count: int
        :param users_user_types: Only show users that are of this type
        :type users_user_types: int
        :param skill_level: Only show users that are of this skill level
        :type skill_level: str
        :param programs: Only show users that use this design program
        :type programs: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_term_typeusers_get_serialize(
            term=term,
            page=page,
            per_page=per_page,
            sort=sort,
            users_thing_count=users_thing_count,
            users_user_types=users_user_types,
            skill_level=skill_level,
            programs=programs,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SearchTermTypeUsersGet200Response",
            '401': "ThingsPost401Response",
            '403': "ThingsPost403Response",
            '404': "ThingsPost404Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_term_typeusers_get_without_preload_content(
        self,
        term: Annotated[Optional[StrictStr], Field(description="The search query to perform")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page for pagination")] = None,
        per_page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Amount of results to show per page")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort method")] = None,
        users_thing_count: Annotated[Optional[StrictInt], Field(description="Only show users that have at least 1 published Thing")] = None,
        users_user_types: Annotated[Optional[StrictInt], Field(description="Only show users that are of this type")] = None,
        skill_level: Annotated[Optional[StrictStr], Field(description="Only show users that are of this skill level")] = None,
        programs: Annotated[Optional[StrictInt], Field(description="Only show users that use this design program")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search for Users

        See [page](https://www.notion.so/makerbot/Thingiverse-Search-API-f7ce7608d54d44f7a2b902a83194a8b2) for complete documentation and all possible parameters.

        :param term: The search query to perform
        :type term: str
        :param page: Page for pagination
        :type page: int
        :param per_page: Amount of results to show per page
        :type per_page: int
        :param sort: Sort method
        :type sort: str
        :param users_thing_count: Only show users that have at least 1 published Thing
        :type users_thing_count: int
        :param users_user_types: Only show users that are of this type
        :type users_user_types: int
        :param skill_level: Only show users that are of this skill level
        :type skill_level: str
        :param programs: Only show users that use this design program
        :type programs: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_term_typeusers_get_serialize(
            term=term,
            page=page,
            per_page=per_page,
            sort=sort,
            users_thing_count=users_thing_count,
            users_user_types=users_user_types,
            skill_level=skill_level,
            programs=programs,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SearchTermTypeUsersGet200Response",
            '401': "ThingsPost401Response",
            '403': "ThingsPost403Response",
            '404': "ThingsPost404Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_term_typeusers_get_serialize(
        self,
        term,
        page,
        per_page,
        sort,
        users_thing_count,
        users_user_types,
        skill_level,
        programs,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if term is not None:
            _path_params['term'] = term
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if per_page is not None:
            
            _query_params.append(('per_page', per_page))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if users_thing_count is not None:
            
            _query_params.append(('users_thing_count', users_thing_count))
            
        if users_user_types is not None:
            
            _query_params.append(('users_user_types', users_user_types))
            
        if skill_level is not None:
            
            _query_params.append(('skill_level', skill_level))
            
        if programs is not None:
            
            _query_params.append(('programs', programs))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/search/{term}/?type=users',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


